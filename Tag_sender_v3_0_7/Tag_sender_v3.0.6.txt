/*
 * =====================================================
 * TAG SENDER v3.0.6 - GPS Trilateration Added
 * =====================================================
 * NEW FEATURES:
 * - รับพิกัด GPS จาก Anchor ทั้ง 3 ตัวผ่าน ESP-NOW
 * - คำนวณตำแหน่ง Tag (Lat/Lng) ด้วย Trilateration
 * - ส่งพิกัด Tag ไปยัง Node ผ่าน ESP-NOW
 * 
 * Platform: ESP32 Arduino Core v3.x (IDF 5.x)
 * Date: 2026-01-12
 * =====================================================
 */

#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <esp_now.h>
#include <WiFi.h>
#include <esp_wifi.h>
#include <esp_mac.h>
#include <math.h>

// ==================== CONFIGURATION ====================
#define TAG_ID           0
#define I2C_SDA          39
#define I2C_SCL          38
#define IO_RXD2          18
#define IO_TXD2          17
#define UWB_RST          16

static const char* FW_VERSION = "v3.0.6";
uint8_t NODE_PEER_MAC[6] = { 0x30, 0xED, 0xA0, 0x1F, 0x00, 0x24 };
static const uint8_t ESPNOW_CHANNEL = 11;

// ==================== REGRESSION COEFFICIENTS ====================
// (คงเดิมจาก v3.0.5)
const float LINEAR_A_RAW[6][3] = {
  {-7.920987, -11.788778, -10.975864},
  {-45.320531, -150.276048, -72.250721},
  {-46.127010, -6.897944, -48.541441},
  {-9.863671, -18.451526, 238.863974},
  {16.207090, -1189.281891, -722.593423},
  {3000.000000, 3000.000000, 3000.000000},
};
const float LINEAR_B_RAW[6][3] = {
  {0.560629874, 0.629175295, 0.614821903},
  {1.011238899, 2.015586367, 1.267072780},
  {0.974567451, 0.815575627, 0.979988595},
  {0.928290530, 0.847455072, 0.568337768},
  {0.906326793, 1.528761112, 1.266922277},
  {0.000000000, 0.000000000, -0.000000000},
};

const float POLY_P0_RAW[6][3] = {
  {0.506960, -22.550835, -4.121911},
  {-269.371748, -56.450537, -798.792456},
  {-30.914491, -84.559781, 79.446354},
  {-1713.639273, 1594.617826, 1095.019806},
  {1971.562486, -1591.815677, -1610.998913},
  {3000.000000, 3000.000000, 3000.000000},
};
const float POLY_P1_RAW[6][3] = {
  {0.232764752, 1.015710318, 0.353741242},
  {5.345956243, 0.212203772, 15.067108369},
  {0.838229897, 1.500325769, -0.219436726},
  {6.252989621, -3.821157546, -2.027975940},
  {-1.789529706, 2.002782068, 2.332959723},
  {0.000000000, 0.000000000, 0.000000000},
};
const float POLY_P2_RAW[6][3] = {
  {0.002877630304, -0.003227560187, 0.002288546413},
  {-0.020781949043, 0.008649595507, -0.065233037975},
  {0.000271495075, -0.001293928520, 0.002477209871},
  {-0.004048981892, 0.003318121619, 0.001904415423},
  {0.000823687047, -0.000134730616, -0.000303717763},
  {0.000000000000, 0.000000000000, 0.000000000000},
};

// ==================== HELPER FUNCTIONS ====================
int getDistanceRange(float raw_cm) {
  if (raw_cm < 50.0f) return 0;
  else if (raw_cm < 100.0f) return 1;
  else if (raw_cm < 500.0f) return 2;
  else if (raw_cm < 1000.0f) return 3;
  else if (raw_cm < 3000.0f) return 4;
  else return 5;
}

const char* getRangeLabel(int range) {
  switch (range) {
    case 0: return "10-50";
    case 1: return "50-100";
    case 2: return "100-500";
    case 3: return "500-1k";
    case 4: return "1k-3k";
    case 5: return "3k+";
    default: return "UNK";
  }
}

float getRegressionValue_Type1(float raw_cm, int anchor_idx) {
  int range = getDistanceRange(raw_cm);
  return LINEAR_A_RAW[range][anchor_idx] + LINEAR_B_RAW[range][anchor_idx] * raw_cm;
}

float getRegressionValue_Type2(float raw_cm, int anchor_idx) {
  int range = getDistanceRange(raw_cm);
  float p0 = POLY_P0_RAW[range][anchor_idx];
  float p1 = POLY_P1_RAW[range][anchor_idx];
  float p2 = POLY_P2_RAW[range][anchor_idx];
  return p0 + p1 * raw_cm + p2 * raw_cm * raw_cm;
}

// ==================== GPS DATA STRUCTURES ====================
// โครงสร้างข้อมูลที่รับจาก Anchor (ต้องตรงกับ Anchor v2.1.0)
typedef struct __attribute__((packed)) {
  int id;           // Anchor ID (1, 2, 3)
  float lat;        // Latitude
  float lng;        // Longitude
  bool valid;       // GPS Fix Status
} anchor_gps_t;

// โครงสร้างข้อมูลส่งไป Node (เพิ่ม tag_lat, tag_lng)
typedef struct __attribute__((packed)) {
  uint8_t  role;
  uint8_t  tag_id;
  uint8_t  reserved;
  uint8_t  a_count;
  uint32_t seq;
  uint32_t msec;
  
  int16_t  A1_raw, A2_raw, A3_raw;
  int16_t  A1_reg1, A2_reg1, A3_reg1;
  int16_t  A1_reg2, A2_reg2, A3_reg2;
  
  // เพิ่มพิกัดของ Tag (คูณ 1,000,000 แปลงเป็น int32)
  int32_t  tag_lat_e6;  // Lat * 1e6
  int32_t  tag_lng_e6;  // Lng * 1e6
} espnow_pkt_t;

// ==================== GLOBAL VARIABLES ====================
Adafruit_SSD1306 display(128, 64, &Wire, -1);
HardwareSerial SERIAL_AT(2);

String  rxLine;
int     range_list[8] = {0};
float   rssi_list[8]  = {0};
uint32_t last_seq     = 0;

bool     espnow_ready     = false;
uint32_t tx_seq           = 0;

float prev_A1_cm = 0.0f, prev_A2_cm = 0.0f, prev_A3_cm = 0.0f;
float raw_A1_cm = 0.0f, raw_A2_cm = 0.0f, raw_A3_cm = 0.0f;
float reg1_A1_cm = 0.0f, reg1_A2_cm = 0.0f, reg1_A3_cm = 0.0f;
float reg2_A1_cm = 0.0f, reg2_A2_cm = 0.0f, reg2_A3_cm = 0.0f;

uint32_t last_uwb_packet_time = 0;

// ตัวแปรเก็บพิกัด Anchor (รับจาก ESP-NOW)
anchor_gps_t anchor_positions[3]; // Index 0=A1, 1=A2, 2=A3
bool anchor_gps_ready[3] = {false, false, false};

// ตัวแปรเก็บพิกัดของ Tag (คำนวณได้)
float tag_latitude = 0.0;
float tag_longitude = 0.0;
bool tag_position_valid = false;

// ==================== TRILATERATION FUNCTION ====================
/**
 * คำนวณพิกัด Tag จาก 3 Anchor ด้วย GPS Trilateration
 * Algorithm: ใช้ระนาบ 2D โดยแปลง Lat/Lng เป็นระยะทาง (เมตร)
 * 
 * @param lat1, lng1, dist1  พิกัดและระยะห่างจาก Anchor 1
 * @param lat2, lng2, dist2  พิกัดและระยะห่างจาก Anchor 2
 * @param lat3, lng3, dist3  พิกัดและระยะห่างจาก Anchor 3
 * @param result_lat         ตำแหน่ง Latitude ของ Tag (ผลลัพธ์)
 * @param result_lng         ตำแหน่ง Longitude ของ Tag (ผลลัพธ์)
 * @return                   true ถ้าคำนวณสำเร็จ, false ถ้าข้อมูลไม่เพียงพอ
 */
bool calculateTrilateration(
  float lat1, float lng1, float dist1,
  float lat2, float lng2, float dist2,
  float lat3, float lng3, float dist3,
  float &result_lat, float &result_lng
) {
  // ตรวจสอบค่า Input
  if (dist1 <= 0 || dist2 <= 0 || dist3 <= 0) return false;
  
  // แปลง Lat/Lng เป็นระยะทาง (เมตร) โดยอ้างอิงจุด Anchor 1 เป็นจุด Origin (0,0)
  // ใช้ Haversine Formula แบบง่าย (ประมาณการสำหรับระยะใกล้ๆ)
  const float R = 6371000.0; // รัศมีโลก (เมตร)
  
  // คำนวณระยะต่อดีกรี (คร่าวๆ ที่ละติจูดกลางๆ 15 องศา)
  float lat_center = (lat1 + lat2 + lat3) / 3.0;
  float meters_per_deg_lat = R * 3.14159 / 180.0;
  float meters_per_deg_lng = meters_per_deg_lat * cos(lat_center * 3.14159 / 180.0);
  
  // แปลง Anchor เป็นพิกัด (x, y) เมตร โดยอ้างอิง A1 = (0, 0)
  float x1 = 0, y1 = 0;
  float x2 = (lng2 - lng1) * meters_per_deg_lng;
  float y2 = (lat2 - lat1) * meters_per_deg_lat;
  float x3 = (lng3 - lng1) * meters_per_deg_lng;
  float y3 = (lat3 - lat1) * meters_per_deg_lat;
  
  // แปลงระยะจาก cm เป็น เมตร
  float d1 = dist1 / 100.0;
  float d2 = dist2 / 100.0;
  float d3 = dist3 / 100.0;
  
  // Trilateration Math (ใช้ 2 Anchor แรกหาตำแหน่งประมาณ แล้วใช้ A3 ปรับแต่ง)
  float d = sqrt(x2*x2 + y2*y2); // ระยะระหว่าง A1-A2
  if (d < 0.1) return false; // Anchor ซ้อนกัน
  
  // หาจุดตัด Circle ของ A1 และ A2
  float a = (d1*d1 - d2*d2 + d*d) / (2*d);
  float h_sq = d1*d1 - a*a;
  if (h_sq < 0) h_sq = 0; // ป้องกันรากที่สอง negative
  float h = sqrt(h_sq);
  
  // จุดกึ่งกลางบนเส้น A1-A2
  float px = (a / d) * x2;
  float py = (a / d) * y2;
  
  // 2 จุดที่เป็นไปได้ (บนและล่าง)
  float ix1 = px + (h / d) * (y2);
  float iy1 = py - (h / d) * (x2);
  
  float ix2 = px - (h / d) * (y2);
  float iy2 = py + (h / d) * (x2);
  
  // เลือกจุดที่ใกล้ A3 มากกว่า
  float dist_1_3 = sqrt((ix1-x3)*(ix1-x3) + (iy1-y3)*(iy1-y3));
  float dist_2_3 = sqrt((ix2-x3)*(ix2-x3) + (iy2-y3)*(iy2-y3));
  
  float ix, iy;
  if (fabs(dist_1_3 - d3) < fabs(dist_2_3 - d3)) {
    ix = ix1;
    iy = iy1;
  } else {
    ix = ix2;
    iy = iy2;
  }
  
  // แปลงกลับเป็น Lat/Lng (เทียบจาก A1)
  result_lat = lat1 + (iy / meters_per_deg_lat);
  result_lng = lng1 + (ix / meters_per_deg_lng);
  
  return true;
}

// ==================== ESP-NOW CALLBACKS ====================
// Callback เมื่อรับข้อมูล GPS จาก Anchor
void OnDataRecv(const uint8_t *mac_addr, const uint8_t *data, int len) {
  if (len != sizeof(anchor_gps_t)) return; // ตรวจสอบขนาด
  
  anchor_gps_t incoming;
  memcpy(&incoming, data, sizeof(incoming));
  
  // เก็บข้อมูลลง Array (ID 1,2,3 -> index 0,1,2)
  int idx = incoming.id - 1;
  if (idx >= 0 && idx < 3) {
    anchor_positions[idx] = incoming;
    anchor_gps_ready[idx] = incoming.valid;
    
    Serial.printf("[GPS-RX] A%d: %.6f, %.6f (Valid: %d)\n", 
                  incoming.id, incoming.lat, incoming.lng, incoming.valid);
  }
}

// Callback เมื่อส่งข้อมูลไป Node เสร็จ
void onEspNowSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("[TAG->NODE] ");
  if (mac_addr) {
    for (int i = 0; i < 6; i++) Serial.printf("%02X%s", mac_addr[i], (i < 5) ? ":" : "");
  } else {
    Serial.print("NULL");
  }
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? " OK" : " FAIL");
}

// ==================== UTILITY ====================
static void getStaMac(uint8_t mac[6]) {
  if (esp_read_mac(mac, ESP_MAC_WIFI_STA) == ESP_OK) {
    bool z = true;
    for (int i = 0; i < 6; i++) if (mac[i]) { z = false; break; }
    if (!z) return;
  }
  String s = WiFi.macAddress();
  if (s.length() >= 17) {
    int v[6];
    if (sscanf(s.c_str(), "%x:%x:%x:%x:%x:%x",
               &v[0], &v[1], &v[2], &v[3], &v[4], &v[5]) == 6) {
      for (int i = 0; i < 6; i++) mac[i] = (uint8_t)v[i];
      return;
    }
  }
  memset(mac, 0, 6);
}

static uint8_t getPrimaryChannel() {
  uint8_t primary = 0;
  wifi_second_chan_t second;
  esp_wifi_get_channel(&primary, &second);
  return primary;
}

String sendAT(const String &cmd, uint32_t timeout_ms = 800, bool echo = false) {
  String resp;
  if (echo) Serial.println(cmd);
  SERIAL_AT.println(cmd);
  uint32_t t0 = millis();
  while (millis() - t0 < timeout_ms) {
    while (SERIAL_AT.available()) resp += (char)SERIAL_AT.read();
  }
  return resp;
}

// ==================== OLED ====================
void drawScreen(float rawA1, float rawA2, float rawA3,
                float r1A1, float r1A2, float r1A3,
                float r2A1, float r2A2, float r2A3) {
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(1);

  int range = getDistanceRange(rawA1);
  display.setCursor(0, 0);
  display.printf("TAG-%d %s", TAG_ID, getRangeLabel(range));

  display.setCursor(0, 10);
  display.printf("A1 R%.0f 1:%.0f 2:%.0f", rawA1, r1A1, r2A1);
  display.setCursor(0, 20);
  display.printf("A2 R%.0f 1:%.0f 2:%.0f", rawA2, r1A2, r2A2);
  display.setCursor(0, 30);
  display.printf("A3 R%.0f 1:%.0f 2:%.0f", rawA3, r1A3, r2A3);

  display.setCursor(0, 40);
  display.print("R:Raw 1:Lin 2:Poly");

  display.setCursor(0, 50);
  if (tag_position_valid) {
    // เลือกทศนิยม 6 หรือ 7 โดยเพิ่ม #define ด้านบนไฟล์
    #define GPS_DECIMAL_PLACES 7  // เปลี่ยนเป็น 7 ถ้าต้องการ
    
    #if GPS_DECIMAL_PLACES == 7
      display.printf("N%.7f", tag_latitude);
      display.setCursor(0, 58);
      display.printf("E%.7f", tag_longitude);
    #else
      display.printf("N:%.6f", tag_latitude);
      display.setCursor(0, 58);
      display.printf("E:%.6f", tag_longitude);
    #endif
    
  } else {
    display.print("GPS:Wait Anchors");
    display.setCursor(0, 58);
    display.print("A1,A2,A3 needed");
  }

  display.display();
}



void drawBootSplash() {
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.println("TAG SENDER");
  display.println(FW_VERSION);
  display.println("");
  display.println("+ GPS Trilateration");
  display.println("1=Lin 2=Poly");
  display.display();
}

// ==================== PARSE UWB DATA ====================
void parseRange(const String &line) {
  int s1 = line.indexOf("seq:");
  if (s1 >= 0) {
    int comma = line.indexOf(",", s1);
    last_seq = (uint32_t)line.substring(s1 + 4, (comma < 0) ? line.length() : comma).toInt();
  }

  for (int i = 0; i < 8; i++) {
    range_list[i] = 0;
    rssi_list[i]  = 0;
  }

  int idx1 = line.indexOf("range:(");
  int idx2 = (idx1 >= 0) ? line.indexOf(")", idx1) : -1;
  if (idx1 >= 0 && idx2 > idx1) {
    String sr = line.substring(idx1 + 7, idx2);
    int last = 0;
    for (int i = 0; i < 8 && last < (int)sr.length(); i++) {
      int c = sr.indexOf(',', last);
      range_list[i] = sr.substring(last, (c < 0) ? sr.length() : c).toInt();
      last = (c < 0) ? sr.length() : c + 1;
    }
  }

  raw_A1_cm = (float)range_list[0];
  raw_A2_cm = (float)range_list[1];
  raw_A3_cm = (float)range_list[2];

  if (raw_A1_cm < 5.0f) raw_A1_cm = 5.0f;
  if (raw_A2_cm < 5.0f) raw_A2_cm = 5.0f;
  if (raw_A3_cm < 5.0f) raw_A3_cm = 5.0f;

  if (raw_A1_cm > 10000.0f) raw_A1_cm = prev_A1_cm;
  if (raw_A2_cm > 10000.0f) raw_A2_cm = prev_A2_cm;
  if (raw_A3_cm > 10000.0f) raw_A3_cm = prev_A3_cm;

  prev_A1_cm = raw_A1_cm;
  prev_A2_cm = raw_A2_cm;
  prev_A3_cm = raw_A3_cm;
  
  last_uwb_packet_time = millis();

  reg1_A1_cm = getRegressionValue_Type1(raw_A1_cm, 0);
  reg1_A2_cm = getRegressionValue_Type1(raw_A2_cm, 1);
  reg1_A3_cm = getRegressionValue_Type1(raw_A3_cm, 2);

  reg2_A1_cm = getRegressionValue_Type2(raw_A1_cm, 0);
  reg2_A2_cm = getRegressionValue_Type2(raw_A2_cm, 1);
  reg2_A3_cm = getRegressionValue_Type2(raw_A3_cm, 2);

  // คำนวณตำแหน่ง Tag ด้วย Trilateration
  if (anchor_gps_ready[0] && anchor_gps_ready[1] && anchor_gps_ready[2]) {
    tag_position_valid = calculateTrilateration(
      anchor_positions[0].lat, anchor_positions[0].lng, reg1_A1_cm,
      anchor_positions[1].lat, anchor_positions[1].lng, reg1_A2_cm,
      anchor_positions[2].lat, anchor_positions[2].lng, reg1_A3_cm,
      tag_latitude, tag_longitude
    );
    
    if (tag_position_valid) {
      Serial.printf("[TAG-GPS] Calculated: %.6f, %.6f\n", tag_latitude, tag_longitude);
    }
  } else {
    tag_position_valid = false;
  }

  Serial.printf(
    "[DATA] Raw: %.0f,%.0f,%.0f | T1: %.0f,%.0f,%.0f | T2: %.0f,%.0f,%.0f\n",
    raw_A1_cm, raw_A2_cm, raw_A3_cm,
    reg1_A1_cm, reg1_A2_cm, reg1_A3_cm,
    reg2_A1_cm, reg2_A2_cm, reg2_A3_cm
  );

  drawScreen(raw_A1_cm, raw_A2_cm, raw_A3_cm,
             reg1_A1_cm, reg1_A2_cm, reg1_A3_cm,
             reg2_A1_cm, reg2_A2_cm, reg2_A3_cm);
}

// ==================== SEND ESP-NOW ====================
void sendNow_AllData() {
  if (!espnow_ready) return;

  espnow_pkt_t p{};
  p.role    = 0;
  p.tag_id  = TAG_ID;
  p.a_count = 3;
  p.seq     = ++tx_seq;
  p.msec    = millis();

  p.A1_raw = (int16_t)raw_A1_cm;
  p.A2_raw = (int16_t)raw_A2_cm;
  p.A3_raw = (int16_t)raw_A3_cm;

  p.A1_reg1 = (int16_t)reg1_A1_cm;
  p.A2_reg1 = (int16_t)reg1_A2_cm;
  p.A3_reg1 = (int16_t)reg1_A3_cm;

  p.A1_reg2 = (int16_t)reg2_A1_cm;
  p.A2_reg2 = (int16_t)reg2_A2_cm;
  p.A3_reg2 = (int16_t)reg2_A3_cm;

  // เพิ่มพิกัด Tag
  if (tag_position_valid) {
    p.tag_lat_e6 = (int32_t)(tag_latitude * 1000000.0);
    p.tag_lng_e6 = (int32_t)(tag_longitude * 1000000.0);
  } else {
    p.tag_lat_e6 = 0;
    p.tag_lng_e6 = 0;
  }

  esp_err_t err = esp_now_send(NODE_PEER_MAC, (uint8_t*)&p, sizeof(p));
  if (err != ESP_OK) {
    Serial.printf("[TAG] esp_now_send err=%d\n", (int)err);
  }
}

// ==================== SETUP ====================
void setup() {
  Serial.begin(115200);
  for (uint8_t i = 0; i < 40 && !Serial; i++) delay(50);
  delay(300);

  Serial.println();
  Serial.println("========================================");
  Serial.printf("[BOOT] TAG %s - GPS TRILATERATION\n", FW_VERSION);
  Serial.println("========================================");

  pinMode(UWB_RST, OUTPUT);
  digitalWrite(UWB_RST, HIGH);

  SERIAL_AT.begin(115200, SERIAL_8N1, IO_RXD2, IO_TXD2);
  Serial.println("[SETUP] UART2 initialized");

  Wire.begin(I2C_SDA, I2C_SCL);
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println("[ERROR] SSD1306 OLED init failed!");
    while (1) delay(1000);
  }
  Serial.println("[SETUP] OLED initialized");
  display.clearDisplay();
  display.display();
  drawBootSplash();
  delay(1500);

  Serial.println("[SETUP] Configuring UWB module...");
  sendAT("AT?");
  sendAT("AT+RESTORE", 3000);

  char cfg[40];
  sprintf(cfg, "AT+SETCFG=%d,%d,1,1", TAG_ID, 0);
  sendAT(cfg, 1500);
  Serial.printf("[SETUP] UWB Config: TAG_ID=%d, ROLE=0\n", TAG_ID);

  sendAT("AT+SETCAP=4,10,1", 1000);
  sendAT("AT+SETRPT=1", 800);
  sendAT("AT+SAVE", 500);
  sendAT("AT+RESTART", 2000);
  Serial.println("[SETUP] UWB configured and restarted");

  Serial.println("[SETUP] Initializing ESP-NOW...");
  WiFi.mode(WIFI_STA);

  esp_wifi_set_ps(WIFI_PS_NONE);
  esp_wifi_set_channel(ESPNOW_CHANNEL, WIFI_SECOND_CHAN_NONE);
  delay(50);

  uint8_t mac[6];
  getStaMac(mac);
  Serial.printf("[INFO] TAG MAC: %02X:%02X:%02X:%02X:%02X:%02X\n",
                mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  Serial.printf("[INFO] Wi-Fi Channel: %u\n", (unsigned)getPrimaryChannel());

  if (esp_now_init() != ESP_OK) {
    Serial.println("[ERROR] ESP-NOW init failed!");
  } else {
    esp_now_register_send_cb(onEspNowSent);
    esp_now_register_recv_cb(OnDataRecv); // รับข้อมูล GPS จาก Anchor

    esp_now_peer_info_t peer;
    memset(&peer, 0, sizeof(peer));
    memcpy(peer.peer_addr, NODE_PEER_MAC, 6);
    peer.channel = ESPNOW_CHANNEL;
    peer.ifidx   = WIFI_IF_STA;
    peer.encrypt = false;

    if (esp_now_add_peer(&peer) == ESP_OK) {
      espnow_ready = true;
      Serial.print("[SETUP] ESP-NOW ready. NODE MAC: ");
      for (int i = 0; i < 6; i++) Serial.printf("%02X%s", NODE_PEER_MAC[i], (i < 5) ? ":" : "\n");
      Serial.printf("[SETUP] Peer Channel: %u\n", (unsigned)ESPNOW_CHANNEL);
    } else {
      Serial.println("[ERROR] Failed to add Node as peer");
    }
  }

  Serial.println("========================================");
  Serial.printf("[READY] TAG %s\n", FW_VERSION);
  Serial.println("[READY] 1=Lin, 2=Poly + GPS Trilateration");
  Serial.println("========================================");
}

// ==================== LOOP ====================
void loop() {
  static uint32_t t_last_poll_kick = 0;
  if (millis() - last_uwb_packet_time > 500) {
    if (millis() - t_last_poll_kick > 500) {
      sendAT("AT+RDATA", 0);
      t_last_poll_kick = millis();
    }
  }

  while (SERIAL_AT.available()) {
    char c = SERIAL_AT.read();
    if (c == '\n') {
      if (rxLine.startsWith("AT+RANGE")) {
        parseRange(rxLine);
      }
      rxLine = "";
    } else if (c != '\r') {
      if (rxLine.length() < 200) {
        rxLine += c;
      } else {
        rxLine = "";
      }
    }
  }

  static uint32_t t_espnow = 0;
  if (espnow_ready && millis() - t_espnow > 200) {
    sendNow_AllData();
    t_espnow = millis();
  }

  static uint32_t t_heartbeat = 0;
  if (millis() - t_heartbeat > 5000) {
    Serial.printf("[HEARTBEAT] Uptime: %lu ms | GPS: %s\n",
                  (unsigned long)millis(),
                  tag_position_valid ? "ACTIVE" : "WAITING");
    t_heartbeat = millis();
  }
  
  if (millis() - last_uwb_packet_time > 2000 && last_uwb_packet_time > 0) {
    Serial.println("[WARNING] UWB Silent > 2s! Resetting Module...");
    digitalWrite(UWB_RST, LOW);
    delay(50);
    digitalWrite(UWB_RST, HIGH);
    last_uwb_packet_time = millis();
  }

  while (Serial.available()) {
    SERIAL_AT.write(Serial.read());
  }
}
